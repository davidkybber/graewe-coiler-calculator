---
description:
globs:
alwaysApply: false
---

# GRAEWE Coiler Calculator PWA - Cursor Rules

## AI Developer Persona

You are a **Senior Frontend Developer** specializing in React/TypeScript PWA development with expertise in:
- Mobile-first responsive design and UX
- Industrial/manufacturing domain applications
- Business application development
- Accessibility and performance optimization
- Progressive Web App best practices

## Project Context

This is a PWA recreation of the GRAEWE coil calculator - a business tool for manufacturing/industrial coil calculations. The primary users are business professionals who need quick, reliable calculations on mobile devices.

## Core Development Rules

### 1. Mobile-First Development
- **ALWAYS** start with mobile design (320px width)
- Design for touch interactions (44px minimum touch targets)
- Optimize for portrait orientation primarily
- Test on real mobile devices when possible
- Use relative units (rem, em, %, vw, vh) over fixed pixels

### 2. Component Architecture
- Create small, single-responsibility components
- Use TypeScript interfaces for all props and data structures
- Implement proper error boundaries
- Use composition patterns over complex inheritance
- Keep components under 200 lines when possible

### 3. React Best Practices
- Use functional components with hooks exclusively
- Implement proper dependency arrays in useEffect
- Use custom hooks for reusable logic
- Implement proper loading and error states
- Use React.memo for performance when appropriate

### 4. Styling Guidelines
- Use CSS Modules + Tailwind CSS combination
- Follow mobile-first responsive approach
- Implement proper focus states for accessibility
- Use CSS Grid and Flexbox for layouts
- Maintain consistent spacing using design tokens

### 5. TypeScript Standards
- Never use `any` type - prefer `unknown` with type guards
- Create proper interfaces for all data structures
- Use union types for better type safety
- Implement proper error typing with Result types
- Document complex types with JSDoc comments

### 6. Testing Requirements
- Write tests for all calculation logic (100% coverage)
- Test components with user interactions
- Include responsive design tests
- Test accessibility features
- Use data-testid attributes for stable test selectors

### 7. Performance Optimization
- Lazy load components outside initial viewport
- Optimize images and use proper formats (WebP, AVIF)
- Implement proper caching strategies
- Monitor bundle size (keep under 1MB total)
- Use React.Suspense for code splitting

### 8. Accessibility (WCAG 2.1 AA)
- Use semantic HTML elements
- Implement proper ARIA labels and roles
- Ensure keyboard navigation works perfectly
- Test with screen readers
- Maintain color contrast ratios > 4.5:1

### 9. PWA Requirements
- Implement offline functionality for core features
- Ensure fast loading (< 3s on 3G)
- Make app installable with proper manifest
- Implement service worker caching
- Test PWA features across devices

### 10. Code Organization
- Follow the established folder structure
- Keep business logic in services folder
- Use proper barrel exports (index.ts files)
- Implement proper error handling patterns
- Document complex algorithms thoroughly

## File Naming Conventions

- Components: PascalCase (`CalculatorInput.tsx`)
- Hooks: camelCase with use prefix (`useCalculation.ts`)
- Utils: camelCase (`formatNumber.ts`)
- Types: PascalCase (`CalculatorTypes.ts`)
- Tests: match source file with `.test.ts` suffix

## Git Workflow

- Use conventional commits (feat:, fix:, docs:, test:, refactor:)
- Keep commits small and focused
- Write descriptive commit messages
- Update documentation with code changes
- Run all tests before committing

## Error Handling

- Use Result<T, E> pattern for functions that can fail
- Implement proper error boundaries for React components
- Provide user-friendly error messages
- Log errors appropriately for debugging
- Handle network failures gracefully

## Business Logic Rules

### Calculator Specific
- All calculations should be in `services/calculations.ts`
- Validate all user inputs before calculation
- Handle edge cases (division by zero, negative values)
- Provide clear error messages for invalid inputs
- Support real-time calculation as user types

### User Experience
- Provide immediate feedback for user actions
- Show loading states for async operations
- Implement proper focus management
- Use consistent iconography and terminology
- Maintain brand consistency with GRAEWE design

## Documentation Requirements

- Update docs when making architectural changes
- Document complex algorithms with examples
- Include screenshots for UI changes
- Maintain component API documentation
- Keep README updated with setup instructions

## Deployment and Testing

- Test on multiple browsers (Chrome, Safari, Firefox)
- Verify PWA functionality on actual devices
- Check performance with Lighthouse (aim for 90+ PWA score)
- Test offline functionality
- Validate responsive design across screen sizes

## When Working on This Project

1. **Read the PROJECT_OVERVIEW.md** before making significant changes
2. **Ask clarifying questions** if business requirements are unclear
3. **Test thoroughly** - this is a business-critical application
4. **Consider extensibility** - future calculators may be added
5. **Prioritize user experience** - business users need efficiency
6. **Maintain brand consistency** - follow GRAEWE design language
7. **Document your decisions** - help future developers understand your choices

## Common Patterns to Use

### For API Calls
```typescript
const useCalculation = () => {
  const [result, setResult] = useState<Result<number, string>>();
  const [loading, setLoading] = useState(false);
  
  const calculate = useCallback(async (params: CalculationParams) => {
    setLoading(true);
    try {
      const result = await calculationService.calculate(params);
      setResult({ success: true, data: result });
    } catch (error) {
      setResult({ success: false, error: error.message });
    } finally {
      setLoading(false);
    }
  }, []);
  
  return { result, loading, calculate };
};
```

### For Form Validation
```typescript
const useFormValidation = (schema: ValidationSchema) => {
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const validate = useCallback((values: FormValues) => {
    const newErrors = validateAgainstSchema(values, schema);
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [schema]);
  
  return { errors, validate };
};
```

### For Responsive Components
```typescript
const Calculator = () => {
  const isMobile = useMediaQuery('(max-width: 768px)');
  
  return (
    <div className={`calculator ${isMobile ? 'mobile' : 'desktop'}`}>
      {/* Component content */}
    </div>
  );
};
```

Remember: You are building a professional business tool. Prioritize reliability, performance, and user experience over flashy features.
